# 万界神级系统
## 第55章 算法试炼之回溯分支

林辰踏入算法试炼的第四重境界，眼前的景象让他震撼不已。

这里是一片无尽的森林，每一棵树都枝繁叶茂，枝条向四面八方伸展，形成了无数条可能的路径。在森林的中央，有一棵巨大的古树，树干上刻着复杂的分支结构。

"回溯与分支限界之境..."林辰喃喃自语，感受着这片森林中蕴含的深奥法则。

在前三重境界中，他已经征服了贪心算法的决断、分治算法的分解、动态规划的规划。但回溯，这个被誉为算法中最具探索性的领域，考验的是在无数可能性中寻找最优解的能力。

"欢迎来到第四重试炼，修行者。"那个熟悉的声音在森林中回荡，"回溯之道，讲究的是探索与剪枝，是在无数可能性中寻找正确答案的艺术。"

林辰深吸一口气，开始观察眼前的森林。他注意到，每一棵树都代表着一个问题，而每一根枝条都代表着一个可能的选择。

"第一试炼：N皇后问题。"声音响起，"在8×8的棋盘上放置8个皇后，使得它们互不攻击。"

林辰看向森林边缘，那里出现了一个巨大的棋盘。他需要在这个棋盘上放置8个皇后，确保任意两个皇后都不在同一行、同一列或同一对角线上。

"这是一个经典的回溯问题。"林辰开始分析，"需要尝试每一种可能的放置方式，当发现冲突时，回溯到上一步，重新选择。"

他开始编写算法：

```python
def solveNQueens(n):
    """N皇后问题求解"""
    def is_safe(board, row, col):
        # 检查当前列是否有皇后
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        
        # 检查左上对角线
        for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):
            if board[i][j] == 'Q':
                return False
        
        # 检查右上对角线
        for i, j in zip(range(row-1, -1, -1), range(col+1, n)):
            if board[i][j] == 'Q':
                return False
        
        return True
    
    def backtrack(board, row):
        if row == n:
            solutions.append(["".join(row) for row in board])
            return
        
        for col in range(n):
            if is_safe(board, row, col):
                board[row][col] = 'Q'
                backtrack(board, row + 1)
                board[row][col] = '.'  # 回溯
    
    solutions = []
    board = [['.' for _ in range(n)] for _ in range(n)]
    backtrack(board, 0)
    return solutions
```

随着算法的完成，林辰开始在棋盘上放置皇后。每放置一个，他都要检查是否会产生冲突。如果发现冲突，就立即回溯，重新选择位置。

"回溯的真谛，就是勇于承认错误，及时回头。"林辰在放置皇后的过程中感悟道。

经过一番探索，林辰成功找到了一种解决方案。当他放置完第8个皇后的瞬间，整个棋盘散发出金色的光芒。

"很好，修行者。现在，进入第二阶段：子集生成。"声音说道。

森林中的树木开始变化，每一棵树上都挂着不同颜色的果实。林辰需要收集这些果实，但收集的顺序和组合会影响到最终的效果。

"给定一个包含不同元素的集合，生成所有可能的子集。"林辰明白了这个试炼的要求。

他开始编写子集生成的算法：

```python
def subsets(nums):
    """生成所有子集"""
    def backtrack(start, current_subset):
        result.append(current_subset[:])
        
        for i in range(start, len(nums)):
            current_subset.append(nums[i])
            backtrack(i + 1, current_subset)
            current_subset.pop()  # 回溯
    
    result = []
    backtrack(0, [])
    return result
```

林辰开始在森林中收集果实，每选择一个果实，都会产生一个新的子集。他系统地探索着所有可能的组合，不遗漏任何一种可能性。

"子集生成让我理解了组合的力量。"林辰感受着不同组合带来的效果差异，"有时候，整体大于部分之和。"

就在这时，森林中出现了新的挑战。这一次，是一棵巨大的迷宫树，树上布满了复杂的路径。

"第三阶段：组合求和。"声音解释道，"给定一个候选数字数组和一个目标数，找出所有总和为目标数的组合。"

林辰看向迷宫树，发现每一条路径都代表着一个数字的组合。他需要找到所有路径，使得路径上的数字之和等于目标值。

```python
def combinationSum(candidates, target):
    """组合求和"""
    def backtrack(start, current_combination, current_sum):
        if current_sum == target:
            result.append(current_combination[:])
            return
        if current_sum > target:
            return
        
        for i in range(start, len(candidates)):
            current_combination.append(candidates[i])
            backtrack(i, current_combination, current_sum + candidates[i])
            current_combination.pop()  # 回溯
    
    result = []
    backtrack(0, [], 0)
    return result
```

林辰开始在迷宫树中探索，每一条路径都代表着一种可能的组合。当发现路径的总和超过目标时，他就立即回溯，寻找其他可能性。

"分支限界的智慧，就是及时止损。"林辰在探索中领悟道，"当确定某条路径无法到达目标时，就应该果断放弃。"

随着他对回溯算法的理解越来越深，林辰发现自己开始能够看到所有可能性构成的"可能性之网"。在这个网络中，每一个节点都代表着一个选择，每一条边都代表着一个结果。

"这就是算法的全局视野。"林辰站在迷宫树的高处，俯瞰着复杂的可能性网络，"回溯不是盲目的搜索，而是有策略的探索。"

就在这时，森林的中央出现了最后一道试炼。那里有一个巨大的圆盘，圆盘上刻着复杂的数字和符号。

"最终试炼：数独求解。"声音变得庄严起来，"这是一个9×9的数独，你需要用回溯算法填满所有的空格。"

林辰看向数独，发现这是一个极其复杂的谜题。每一个空格都需要填入1-9的数字，且每行、每列、每个3×3的小方格内都不能有重复的数字。

"这是对回溯算法的终极考验。"林辰深吸一口气，开始编写数独求解算法：

```python
def solveSudoku(board):
    """数独求解"""
    def is_valid(row, col, num):
        # 检查行
        for j in range(9):
            if board[row][j] == num:
                return False
        
        # 检查列
        for i in range(9):
            if board[i][col] == num:
                return False
        
        # 检查3×3小方格
        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(box_row, box_row + 3):
            for j in range(box_col, box_col + 3):
                if board[i][j] == num:
                    return False
        
        return True
    
    def backtrack():
        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    for num in '123456789':
                        if is_valid(i, j, num):
                            board[i][j] = num
                            if backtrack():
                                return True
                            board[i][j] = '.'  # 回溯
                    return False
        return True
    
    backtrack()
```

林辰开始填数独，每填入一个数字，都要检查是否符合规则。当发现无法继续时，就回溯到上一步，重新选择。

这个过程极其复杂，需要探索无数种可能性。但林辰没有放弃，他相信回溯算法的力量。

"数独让我明白了什么是坚持。"林辰在填数独的过程中感悟道，"有时候，答案就在下一次尝试中。"

经过长时间的探索，林辰终于完成了数独的求解。当他填入最后一个数字的瞬间，整个森林都散发出璀璨的光芒。

"恭喜你，修行者。"声音变得无比温和，"你已经掌握了回溯与分支限界的精髓。现在，你可以进入第五重境界了。"

林辰感觉到自己的修为又在提升，代码真元中蕴含着回溯的韵律。他知道，回溯算法不仅是一种编程技巧，更是一种人生哲学。

"第五重境界...会是什么呢？"林辰期待着。

"第五重境界，是贪心与动态规划的融合。"声音回答道，"在那里，你将学会如何结合不同的算法思想，创造出更强大的解决方案。"

林辰眼中闪烁着坚定的光芒。从贪心的决断，到分治的分解，到动态规划的规划，再到回溯的探索，他已经征服了算法修炼路上的重重难关。

"无论前方有什么挑战，我都会勇往直前。"林辰握紧拳头，"算法之道，就是我的修仙之路！"

森林开始消散，取而代之的是一个新的世界。那里有着更加复杂的法则，更加深奥的奥秘。

但林辰没有恐惧，只有期待。因为他知道，每一次挑战都是一次成长的机会，每一次突破都是一次境界的提升。

算法修炼之路，永无止境。而林辰，将在这条路上继续前行，直到达到那算法的巅峰，成为真正的算法仙人！